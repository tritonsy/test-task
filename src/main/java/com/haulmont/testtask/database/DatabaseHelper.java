/*
 * The MIT License
 * Copyright © 2019 Kobzarev Alex
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

package com.haulmont.testtask.database;

import java.sql.*;
import java.util.ResourceBundle;

/**
 * Класс для работы с базой данных (HSQLDB).
 * Методы класса с помощью JDBC взаимодействуют с таблицами, записями базы данных.
 * Здесь производится подключение к базе данных и проверка на корректность БД.
 *
 * @author alex
 * @version 1.0
 * @since 2019-11-16
 */
public class DatabaseHelper {

    private static Connection connection = null;

    private DatabaseHelper() {
    }

    public static Connection getConnection() throws Exception {
        if (connection == null) {
            ResourceBundle resource = ResourceBundle.getBundle("database");
            String driver = resource.getString("db.driver");
            String url = resource.getString("db.url");
            String username = resource.getString("db.username");
            String password = resource.getString("db.password");

            Class.forName(driver);
            connection = DriverManager.getConnection(url, username, password);
            initDatabase();
        }
        return connection;
    }

    public static void closeConnection() throws SQLException {
        if (connection != null && !connection.isClosed()) {
            connection.close();
        }
    }

    private static void initDatabase() throws SQLException {
        try (Statement st = connection.createStatement()) {
            if (!tableExists("T_PATIENT")) {
                st.execute("create table T_PATIENT (" +
                        "ID bigint generated by default as identity" +
                        "(start with 1, increment by 1) not null primary key," +
                        "NAME nvarchar(32) not null," +
                        "SURNAME nvarchar(32) not null," +
                        "PATRONYMIC nvarchar(32) not null," +
                        "PHONE_NUMBER nvarchar(32) not null" +
                        ");");

                st.executeUpdate("INSERT INTO T_PATIENT(NAME, SURNAME, PATRONYMIC, PHONE_NUMBER) VALUES\n" +
                        "('Сергеев', 'Александр', 'Антонович', '89273225323');");
                st.executeUpdate("INSERT INTO T_PATIENT(NAME, SURNAME, PATRONYMIC, PHONE_NUMBER) VALUES\n" +
                        "('Иван', 'Петров', 'Сергеевич', '89271235323');");
                st.executeUpdate("INSERT INTO T_PATIENT(NAME, SURNAME, PATRONYMIC, PHONE_NUMBER) VALUES\n" +
                        "('Кларисса', 'Старлинг', 'М.', '89279123452');");
                st.executeUpdate("INSERT INTO T_PATIENT(NAME, SURNAME, PATRONYMIC, PHONE_NUMBER) VALUES\n" +
                        "('Александр', 'Луканов', 'Сергеевич', '89279813254');");
                st.executeUpdate("INSERT INTO T_PATIENT(NAME, SURNAME, PATRONYMIC, PHONE_NUMBER) VALUES\n" +
                        "('Анатолий', 'Степанов', 'Николаевич', '89279182343');");
                st.executeUpdate("INSERT INTO T_PATIENT(NAME, SURNAME, PATRONYMIC, PHONE_NUMBER) VALUES\n" +
                        "('Рената', 'Филатова', 'Александровна', '89279182343');");
            }

            if (!tableExists("T_DOCTOR")) {
                st.execute("create table T_DOCTOR (" +
                        "ID bigint generated by default as identity" +
                        "(start with 1, increment by 1) not null primary key," +
                        "NAME nvarchar(32) not null," +
                        "SURNAME nvarchar(32) not null," +
                        "PATRONYMIC nvarchar(32) not null," +
                        "SPECIALIZATION nvarchar(32) not null" +
                        ");");

                st.executeUpdate("INSERT INTO T_DOCTOR(NAME, SURNAME, PATRONYMIC, SPECIALIZATION) VALUES\n" +
                        "('Сергей', 'Боткин', 'Петрович', 'Терапевт');");
                st.executeUpdate("INSERT INTO T_DOCTOR(NAME, SURNAME, PATRONYMIC, SPECIALIZATION) VALUES\n" +
                        "('Николай', 'Склифосовкий', 'Васильевич', 'Хирург');");
                st.executeUpdate("INSERT INTO T_DOCTOR(NAME, SURNAME, PATRONYMIC, SPECIALIZATION) VALUES\n" +
                        "('Иван', 'Павлов', 'Петрович', 'Физиолог');");
                st.executeUpdate("INSERT INTO T_DOCTOR(NAME, SURNAME, PATRONYMIC, SPECIALIZATION) VALUES\n" +
                        "('Александр', 'Николаевич', 'Бакулев', 'Хирург');");
                st.executeUpdate("INSERT INTO T_DOCTOR(NAME, SURNAME, PATRONYMIC, SPECIALIZATION) VALUES\n" +
                        "('Владимир', 'Бехтерев', 'Михайлович', 'Хирург');");
                st.executeUpdate("INSERT INTO T_DOCTOR(NAME, SURNAME, PATRONYMIC, SPECIALIZATION) VALUES\n" +
                        "('Владимир', 'Филатов', 'Петрович', 'Офтальмолог');");
                st.executeUpdate("INSERT INTO T_DOCTOR(NAME, SURNAME, PATRONYMIC, SPECIALIZATION) VALUES\n" +
                        "('Ганнибал', 'Лектер', 'Диттман', 'Психиатр');");

            }

            if (!tableExists("T_RECEIPT")) {
                st.execute("create table T_RECEIPT (" +
                        "ID bigint generated by default as identity" +
                        "(start with 1, increment by 1) not null primary key," +
                        "DESCRIPTION nvarchar(160) not null," +
                        "PATIENT_ID bigint not null," +
                        "constraint FK_PATIENT_RECEIPT foreign key (PATIENT_ID) references T_PATIENT(ID) on delete restrict,\n" +
                        "DOCTOR_ID bigint not null," +
                        "constraint FK_DOCTOR_RECEIPT foreign key (DOCTOR_ID) references T_DOCTOR(ID) on delete restrict,\n" +
                        "CREATION_DATE date not null," +
                        "EXPIRE_DATE date not null," +
                        "PRIORITY nvarchar(32) not null " +
                        ");");

                st.executeUpdate("INSERT INTO T_RECEIPT(DESCRIPTION, PATIENT_ID, DOCTOR_ID, CREATION_DATE, EXPIRE_DATE, PRIORITY) " +
                        "VALUES ('Туда сюда', 2, 4, '2019-07-09', '2019-09-09', 'Нормальный');");
                st.executeUpdate("INSERT INTO T_RECEIPT(DESCRIPTION, PATIENT_ID, DOCTOR_ID, CREATION_DATE, EXPIRE_DATE, PRIORITY) " +
                        "VALUES ('Логика человеческого восприятия до безобразия изменчива', 3, 7, '1991-02-13', '1991-03-13', 'Срочный');");
                st.executeUpdate("INSERT INTO T_RECEIPT(DESCRIPTION, PATIENT_ID, DOCTOR_ID, CREATION_DATE, EXPIRE_DATE, PRIORITY) " +
                        "VALUES ('Пятое десятое', 5, 4, '2019-07-12', '2019-08-12', 'Немедленный');");
                st.executeUpdate("INSERT INTO T_RECEIPT(DESCRIPTION, PATIENT_ID, DOCTOR_ID, CREATION_DATE, EXPIRE_DATE, PRIORITY) " +
                        "VALUES ('Тут покрутить', 6, 1, '2019-07-12', '2019-08-12', 'Немедленный');");
                st.executeUpdate("INSERT INTO T_RECEIPT(DESCRIPTION, PATIENT_ID, DOCTOR_ID, CREATION_DATE, EXPIRE_DATE, PRIORITY) " +
                        "VALUES ('Там повертеть', 1, 3, '2019-07-12', '2019-08-12', 'Немедленный');");
            }
        }
    }

    private static boolean tableExists(String tableName) throws SQLException {
        boolean isExists = false;
        try (ResultSet rs = connection.getMetaData().getTables(null, null, tableName, null)) {
            while (rs.next()) {
                String tn = rs.getString("TABLE_NAME");
                if (tn != null && tn.equals(tableName)) {
                    isExists = true;
                    break;
                }
            }
        }
        return isExists;
    }
}
